// Copyright (c) 2025 Felix Kahle.
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

//! The Swap Operator.
//!
//! This module implements a pairwise swap operator that explores the neighborhood
//! generated by exchanging the positions of two vessels in the priority queue.
//! It iterates through unique pairs `(i, j)` where `i < j`.
//!
//! The operator respects the provided `Neighborhoods` topology. It only attempts
//! to swap vessels `u` and `v` if `neighborhoods.are_neighbors(u, v)` returns `true`.
//! This allows for pruning the search space based on problem-specific constraints
//! or heuristics (e.g., only swapping vessels that share a resource conflict).

use crate::{
    memory::Schedule, mutator::Mutator, neighborhood::neighborhoods::Neighborhoods,
    operator::local_search_operator::LocalSearchOperator, queue::VesselPriorityQueue,
};
use bollard_search::num::SolverNumeric;

/// An operator that explores swaps between pairs of vessels in the priority queue.
///
/// It maintains iteration cursors `i` and `j` to enumerate all unique pairs
/// in the upper triangular part of the interaction matrix.
#[derive(Debug, Clone, Default)]
pub struct SwapOperator<T, N> {
    i: usize,
    j: usize,
    num_vessels: usize,
    _phantom: std::marker::PhantomData<(T, N)>,
}

impl<T, N> SwapOperator<T, N> {
    /// Creates a new `SwapOperator`.
    pub fn new() -> Self {
        Self {
            i: 0,
            j: 0,
            num_vessels: 0,
            _phantom: std::marker::PhantomData,
        }
    }
}

impl<T, N> LocalSearchOperator<T, N> for SwapOperator<T, N>
where
    T: SolverNumeric,
    N: Neighborhoods,
{
    fn name(&self) -> &str {
        "SwapOperator"
    }

    fn prepare(&mut self, _schedule: &Schedule<T>, queue: &VesselPriorityQueue, _n: &N) {
        self.num_vessels = queue.len();
        self.i = 0;
        self.j = 0;
    }

    fn next_neighbor(
        &mut self,
        _schedule: &Schedule<T>,
        mutator: &mut Mutator<T>,
        neighborhoods: &N,
    ) -> bool {
        // If we don't have enough vessels to make a pair, we are done immediately.
        if self.num_vessels < 2 {
            return false;
        }

        loop {
            // Advance the cursors
            self.j += 1;

            // If j reaches the end, advance i and reset j to i + 1
            if self.j >= self.num_vessels {
                self.i += 1;
                self.j = self.i + 1;
            }

            // Check termination condition
            // If i reaches the second to last element, we have exhausted all pairs (i, j) with i < j.
            if self.i >= self.num_vessels - 1 {
                return false;
            }

            debug_assert!(
                self.i < self.j && self.j < self.num_vessels,
                "invariant of `SwapOperator` violated in `SwapOperator::next_neighbor`: i={}, j={}, num_vessels={}",
                self.i,
                self.j,
                self.num_vessels
            );

            // Topology Check
            // We only proceed with the swap if the topology says these two vessels are relevant to each other.
            // Using unchecked access here is safe because the cursors are strictly bound by self.num_vessels,
            // which is synchronized with the queue in `prepare`.
            let u = mutator.get_unchecked(self.i);
            let v = mutator.get_unchecked(self.j);

            // Safety: Checking neighbors is generally safe; implementation of neighborhoods handles safety.
            let are_neighbors = unsafe { neighborhoods.are_neighbors_unchecked(u, v) };

            if are_neighbors {
                // Apply Mutation
                mutator.swap(self.i, self.j);
                return true;
            }

            // If not neighbors, continue loop to find the next valid pair.
        }
    }

    fn reset(&mut self) {
        self.i = 0;
        // Initialize j to 0 so the first call to next_neighbor increments it to 1.
        // The loop logic starts with `self.j += 1`, so:
        // First it: j=1. check j>=len.
        // Result: i=0, j=1.
        self.j = 0;
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::memory::SearchMemory;
    use crate::neighborhood::topology::StaticTopology;
    use bollard_model::index::{BerthIndex, VesselIndex};
    use bollard_model::model::ModelBuilder;
    use bollard_model::solution::Solution;
    use bollard_model::time::ProcessingTime;

    fn build_model(num_berths: usize, num_vessels: usize) -> bollard_model::model::Model<i64> {
        ModelBuilder::<i64>::new(num_berths, num_vessels).build()
    }

    #[test]
    fn test_next_neighbor_zero_vessels_returns_false() {
        // Empty model and topology
        let model = build_model(0, 0);
        let topology = StaticTopology::from_model(&model);

        // Construct an empty solution
        let solution = Solution::<i64>::new(0, Vec::new(), Vec::new());

        // Initialize search memory and get schedule/mutator
        let mut memory = SearchMemory::<i64>::new();
        memory.initialize(&solution);
        let (schedule, mutator) = memory.prepare_operator();
        let mut mutator = mutator;

        let mut op = SwapOperator::<i64, StaticTopology>::new();
        // Use the queue reference from the mutator to avoid aliasing memory
        op.prepare(schedule, mutator.queue(), &topology);

        // No pairs are available; should immediately return false.
        let moved = op.next_neighbor(schedule, &mut mutator, &topology);
        assert!(
            !moved,
            "next_neighbor should return false with zero vessels"
        );
    }

    #[test]
    fn test_non_neighbors_are_skipped_and_operator_terminates() {
        // Two vessels on disjoint berths (no shared berth) => not neighbors.
        let mut builder = ModelBuilder::<i64>::new(2, 2);

        // Vessel 0 allowed only on berth 0; time window [0, 10)
        builder.set_vessel_processing_time(
            VesselIndex::new(0),
            BerthIndex::new(0),
            ProcessingTime::from_option(Some(10)),
        );
        builder.set_vessel_arrival_time(VesselIndex::new(0), 0);
        builder.set_vessel_latest_departure_time(VesselIndex::new(0), 10);

        // Vessel 1 allowed only on berth 1; time window [0, 10)
        builder.set_vessel_processing_time(
            VesselIndex::new(1),
            BerthIndex::new(1),
            ProcessingTime::from_option(Some(10)),
        );
        builder.set_vessel_arrival_time(VesselIndex::new(1), 0);
        builder.set_vessel_latest_departure_time(VesselIndex::new(1), 10);

        let model = builder.build();
        let topology = StaticTopology::from_model(&model);

        // Build a solution with start times to ensure queue order [0, 1]
        let berths = vec![BerthIndex::new(0), BerthIndex::new(1)];
        let start_times = vec![0, 1]; // strictly increasing, stable order
        let solution = Solution::<i64>::new(0, berths, start_times);

        // Initialize search memory and get schedule/mutator
        let mut memory = SearchMemory::<i64>::new();
        memory.initialize(&solution);
        let (schedule, mutator) = memory.prepare_operator();
        let mut mutator = mutator;

        let mut op = SwapOperator::<i64, StaticTopology>::new();
        op.prepare(schedule, mutator.queue(), &topology);

        // Since they are not neighbors, the operator should scan the single pair and terminate.
        let moved_first = op.next_neighbor(schedule, &mut mutator, &topology);
        assert!(
            !moved_first,
            "next_neighbor should return false when the only pair is not neighbors"
        );

        // Queue remains unchanged. Inspect via mutator.queue() to avoid borrowing memory.
        let buf = mutator.queue().buffer();
        assert_eq!(buf.len(), 2);
        assert_eq!(buf[0].get(), 0);
        assert_eq!(buf[1].get(), 1);

        // Subsequent call should still return false (operator exhausted).
        let moved_second = op.next_neighbor(schedule, &mut mutator, &topology);
        assert!(
            !moved_second,
            "operator should terminate after exhausting all non-neighbor pairs"
        );
    }

    #[test]
    fn test_neighbors_swap_once_then_terminate() {
        // Two vessels sharing the same berth with overlapping windows => neighbors.
        let mut builder = ModelBuilder::<i64>::new(1, 2);

        // Allow both vessels on berth 0
        builder.set_vessel_processing_time(
            VesselIndex::new(0),
            BerthIndex::new(0),
            ProcessingTime::from_option(Some(5)),
        );
        builder.set_vessel_processing_time(
            VesselIndex::new(1),
            BerthIndex::new(0),
            ProcessingTime::from_option(Some(5)),
        );

        // Overlapping windows: vessel 0 [0, 10), vessel 1 [5, 15)
        builder.set_vessel_arrival_time(VesselIndex::new(0), 0);
        builder.set_vessel_latest_departure_time(VesselIndex::new(0), 10);
        builder.set_vessel_arrival_time(VesselIndex::new(1), 5);
        builder.set_vessel_latest_departure_time(VesselIndex::new(1), 15);

        let model = builder.build();
        let topology = StaticTopology::from_model(&model);

        // Build a solution with start times to ensure initial queue order [0, 1]
        let berths = vec![BerthIndex::new(0), BerthIndex::new(0)];
        let start_times = vec![0, 1]; // strictly increasing
        let solution = Solution::<i64>::new(0, berths, start_times);

        // Initialize search memory and get schedule/mutator
        let mut memory = SearchMemory::<i64>::new();
        memory.initialize(&solution);
        let (schedule, mutator) = memory.prepare_operator();
        let mut mutator = mutator;

        let mut op = SwapOperator::<i64, StaticTopology>::new();
        op.prepare(schedule, mutator.queue(), &topology);

        // First call: vessels are neighbors, so it should swap indices (0,1) -> (1,0)
        let moved_first = op.next_neighbor(schedule, &mut mutator, &topology);
        assert!(moved_first, "expected a swap for a neighboring pair");

        let buf = mutator.queue().buffer();
        assert_eq!(buf.len(), 2);
        assert_eq!(buf[0].get(), 1, "queue head should now be vessel 1");
        assert_eq!(buf[1].get(), 0, "queue tail should now be vessel 0");

        // Second call: no more unique pairs remain; operator should terminate.
        let moved_second = op.next_neighbor(schedule, &mut mutator, &topology);
        assert!(
            !moved_second,
            "operator should terminate after exhausting the single pair"
        );

        // Reset should allow re-iteration from the beginning; with two vessels,
        // it will again find the pair (0,1) (in current indices) and attempt to swap back.
        op.reset();

        op.prepare(schedule, mutator.queue(), &topology);
        let moved_third = op.next_neighbor(schedule, &mut mutator, &topology);
        assert!(moved_third, "expected a swap after reset and prepare");

        let buf2 = mutator.queue().buffer();
        assert_eq!(
            buf2[0].get(),
            0,
            "queue should swap back after second valid move"
        );
        assert_eq!(buf2[1].get(), 1);
    }
}
