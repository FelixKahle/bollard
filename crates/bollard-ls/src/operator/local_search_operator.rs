// Copyright (c) 2025 Felix Kahle.
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

//! Module defining the `LocalSearchOperator` abstraction and an iterator adapter for
//! neighborhood exploration in local search.
//!
//! A `LocalSearchOperator` encapsulates the logic for exploring a specific neighborhood
//! over a mutable external genotype, represented by a `VesselPriorityQueue`. It is designed
//! for high-performance search where candidate solutions are generated by applying reversible
//! mutations and evaluated by the search engine. The operator maintains internal state,
//! such as a cursor or move list, to produce a sequence of distinct neighbors without
//! rebuilding its analysis on every step. It prepares once for a new incumbent solution,
//! generates successive neighbors through lightweight mutations, and can be reset to
//! revisit the same neighborhood without repeating expensive precomputation.
//!
//! The provided iterator adapter, `LocalSearchOperatorIterator`, allows treating an operator
//! like a standard Rust iterator in contexts that benefit from iterator-style loops, while
//! still delegating actual evaluation and rollback to the search engine. This separation
//! keeps mutation, decoding, and scoring concerns isolated and supports flexible composition
//! of neighborhood operators under meta-heuristics and multi-restart strategies.
//!
//! Implementations should keep `prepare` focused on extracting actionable structure from
//! the schedule, keep `next_neighbor` fast and deterministic with respect to internal state,
//! and use `reset` to restore the starting position of the exploration sequence without
//! re-analyzing the schedule.

use crate::{
    memory::Schedule, mutator::Mutator, neighborhood::neighborhoods::Neighborhoods,
    queue::VesselPriorityQueue,
};
use bollard_search::num::SolverNumeric;

/// A stateful operator that explores a specific neighborhood in a local search.
///
/// This trait behaves similarly to an [Iterator], but is designed for the high-performance
/// requirements of local search where mutations are applied to an external state
/// and must be reversible.
///
/// ## Lifecycle
///
/// 1. **`prepare`**: Called once when the search reaches a new "best" solution. The operator
///    analyzes the solution and prepares its internal list of potential moves.
/// 2. **`next_neighbor`**: Called repeatedly. Each call applies exactly one mutation to the
///    genotype (queue). If it returns `true`, the search engine decodes and evaluates the candidate.
///    If it returns `false`, the neighborhood is exhausted.
/// 3. **`reset`**: Reverts the operator's internal cursor or counters to the start of the
///    current neighborhood without re-analyzing the schedule.
pub trait LocalSearchOperator<T, N>
where
    T: SolverNumeric,
    N: Neighborhoods,
{
    /// Returns the name of the operator for logging and identification purposes.
    fn name(&self) -> &str;

    /// Prepares the operator to explore the neighborhood of a new solution.
    ///
    /// This is the "heavy lifting" phase where the operator might:
    /// - Identify "bottleneck" vessels in the `schedule` to target for mutation.
    /// - Pre-calculate a list of vessel pairs for swapping.
    /// - Shuffle or re-order its internal move list if the operator is stochastic.
    fn prepare(&mut self, schedule: &Schedule<T>, queue: &VesselPriorityQueue, neighborhoods: &N);

    /// Applies the next mutation in the neighborhood sequence.
    ///
    /// The operator uses the provided `mutator` to modify the `VesselPriorityQueue`.
    /// The search engine will handle the evaluation and potential rollback of these changes.
    ///
    /// # Returns
    /// - `true`: A mutation was successfully applied. The search engine should now evaluate
    ///   the new candidate.
    /// - `false`: No more neighbors exist in this specific neighborhood.
    ///
    /// # Note
    /// It is expected that the operator manages an internal "cursor" to ensure that
    /// subsequent calls result in different neighbors.
    fn next_neighbor(&mut self, schedule: &Schedule<T>, mutator: &mut Mutator<T>, n: &N) -> bool;

    /// Resets the operator's internal state to the beginning of the neighborhood.
    ///
    /// Unlike `prepare`, `reset` should not perform expensive re-analysis of the schedule.
    /// It simply moves the internal iteration cursor back to the first potential neighbor.
    /// This is useful for multi-restart strategies or meta-heuristics that need to
    /// re-examine the same neighborhood multiple times.
    fn reset(&mut self);
}

impl<T, N> std::fmt::Debug for dyn LocalSearchOperator<T, N>
where
    T: SolverNumeric,
    N: Neighborhoods,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LocalSearchOperator {{ name: {} }}", self.name())
    }
}

impl<T, N> std::fmt::Display for dyn LocalSearchOperator<T, N>
where
    T: SolverNumeric,
    N: Neighborhoods,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}

/// An iterator adapter that allows using a `LocalSearchOperator` in iterator contexts.
#[derive(Debug)]
pub struct LocalSearchOperatorIterator<'a, T, N, O>
where
    T: SolverNumeric,
    N: Neighborhoods,
    O: LocalSearchOperator<T, N>,
{
    operator: &'a mut O,
    neighborhoods: &'a N,
    schedule: &'a Schedule<T>,
    mutator: &'a mut Mutator<'a, T>,
}

impl<'a, T, N, O> LocalSearchOperatorIterator<'a, T, N, O>
where
    T: SolverNumeric,
    N: Neighborhoods,
    O: LocalSearchOperator<T, N>,
{
    pub fn new(
        operator: &'a mut O,
        neighborhoods: &'a N,
        schedule: &'a Schedule<T>,
        mutator: &'a mut Mutator<'a, T>,
    ) -> Self {
        Self {
            operator,
            neighborhoods,
            schedule,
            mutator,
        }
    }
}

impl<'a, T, N, O> Iterator for LocalSearchOperatorIterator<'a, T, N, O>
where
    T: SolverNumeric,
    N: Neighborhoods,
    O: LocalSearchOperator<T, N>,
{
    type Item = ();

    fn next(&mut self) -> Option<Self::Item> {
        if self
            .operator
            .next_neighbor(self.schedule, self.mutator, self.neighborhoods)
        {
            Some(())
        } else {
            None
        }
    }
}
